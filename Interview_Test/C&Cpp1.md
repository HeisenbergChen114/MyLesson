# 1.链表和数组有什么区别？

从内存分配的角度上看：数组在声明时需要指定固定的大小，并且所有元素在连续的内存块中分配。链表只需要在需要增加时进行动态分配其数据空间。它的节点含有数据和指向其他节点指针，内存位置不连续。

从查询的角度：数组：通过索引直接访问元素，访问速度很快，时间复杂度为 O(1)。链表：必须从第一个节点开始遍历，直到找到所需的节点，访问特定元素的时间复杂度为 O(n)。

增删的角度：

数组：插入和删除元素可能需要移动大量元素以维护连续性，特别是对于非末尾的操作，时间复杂度为 O(n)。链表：插入和删除操作通常只需要改变指针，不需要移动其他元素，时间复杂度为 O(1) 或 O(n)（取决于是否知道插入点的前一个节点）。

内存大小的可变性来看：数组：大小固定，一旦声明就不能改变。如果需要更大的数组，必须创建一个新的数组并复制数据。链表：大小动态可变，可以随时添加或删除节点，不需要重新分配整个结构。

随机访问的角度：数组：支持随机访问，可以直接获取任意索引的元素。链表：不支持随机访问，必须顺序访问元素。

显然通过他们的性质可知：数组：适用于数据大小固定、需要频繁随机访问的场景。链表：适用于数据大小动态变化、插入和删除操作频繁的场景。

# Qt有哪些主要的优点？
Qt是一个跨平台的C++应用程序开发框架，具有许多优点：

跨平台性：Qt可以在多个操作系统上运行，包括Windows、macOS和Linux，这意味着开发者可以使用相同的代码库在不同的平台上进行开发，减少了重复开发的工作量。

组件丰富：Qt提供了丰富的组件和模块，涵盖了图形用户界面、网络通信、数据库连接、XML处理等多个方面，使得开发者可以快速构建功能丰富的应用程序。

易用性：Qt具有直观的API和文档，使得开发者可以快速上手并且高效地进行开发。此外，Qt Creator作为集成开发环境也提供了丰富的工具来辅助开发。

强大的社区支持：Qt拥有一个庞大的社区，开发者可以在社区中获得支持、交流经验，并且可以使用社区贡献的开源模块来扩展Qt的功能。

支持多种编程语言：除了C++，Qt还支持Python、JavaScript等编程语言，这使得开发者可以根据自己的需求选择合适的语言来进行开发。

# 描述qt信号与槽

在Qt框架中，信号（Signals）和槽（Slots）是一种用于对象间通信的机制。它允许对象之间进行松耦合的交互，这意味着一个对象可以在不知道接收对象具体细节的情况下发送一个信号，而另一个对象可以连接到这个信号并定义相应的行为（槽）来响应它。



### 信号（Signals）



信号是类的一个特殊成员函数，当某个事件触发时被发射（Emit）。信号可以传递参数，这些参数将被发送给连接到信号的槽。信号的声明使用`signals`关键字，并且信号声明中不能包含返回类型。



```cpp

class MyClass : public QObject {

  Q_OBJECT



public:

  MyClass(QObject *parent = nullptr) : QObject(parent) {}



signals:

  void mySignal(int value); // 声明一个不返回任何值且带一个int参数的信号

};

```



### 槽（Slots）



槽是类中普通的成员函数，它们可以接收来自信号的参数。槽的声明使用`slots`关键字，并且可以有任意的返回类型和参数。



```cpp

class MyReceiver : public QObject {

  Q_OBJECT



public:

  MyReceiver(QObject *parent = nullptr) : QObject(parent) {}



public slots:

  void mySlot(int value) { /* 处理接收到的信号 */ }

};

```



### 连接信号与槽



在Qt中，可以使用`QObject::connect()`函数来连接信号和槽。这个函数需要三个参数：发送信号的对象、信号、接收信号的对象和槽。



```cpp

MyClass sender;

MyReceiver receiver;


// 连接MyClass的mySignal信号到MyReceiver的mySlot槽

QObject::connect(&sender, &MyClass::mySignal, &receiver, &MyReceiver::mySlot);

```

Emit sender.mySignal(1);

当`sender`对象的`mySignal`被发射时，`receiver`对象的`mySlot`将被调用。


### 特点

- **类型安全**：Qt的信号和槽机制支持类型检查，确保连接的信号和槽参数类型匹配。

- **可重载**：可以有多个具有不同参数的信号和槽。

- **线程安全**：Qt支持跨线程的信号和槽连接，但需要使用`Qt::QueuedConnection`作为连接类型。

- **灵活**：信号可以被任何对象发射，槽可以定义在任何继承自`QObject`的对象中。


使用信号和槽的好处在于它提供了一种非常灵活和强大的通信机制，使得你可以轻松地在不同的对象之间传递消息，同时保持代码的清晰和易于维护。


# 说一下QT都有哪些事件？

鼠标事件：包括鼠标按下、释放、移动等事件，可以通过这些事件响应用户的鼠标操作。



键盘事件：包括按键按下、释放、输入等事件，用于处理键盘输入。



定时器事件：用于定时执行特定的操作，例如在一定时间间隔内触发某个函数或操作。



绘图事件：当需要在窗口中进行绘图时，可以使用绘图事件来进行处理。



窗口事件：包括窗口大小改变、关闭、最小化等事件，用于响应窗口状态的变化。



焦点事件：用于处理控件或窗口获得或失去焦点的情况。

鼠标事件示例：
```cpp
// 键盘事件示例
void MyWidget::keyPressEvent(QKeyEvent *event) {
    if (event->key() == Qt::Key_Escape) {
        qDebug() << "Escape key pressed";
    }
}

// 定时器事件示例
void MyWidget::timerEvent(QTimerEvent *event) {
    if (event->timerId() == m_timerId) {
        qDebug() << "Timer event triggered";
    }
}

// 绘图事件示例
void MyWidget::paintEvent(QPaintEvent *event) {
    QPainter painter(this);
    painter.drawText(rect(), Qt::AlignCenter, "Hello, Qt!");
}

// 窗口事件示例
void MyWidget::resizeEvent(QResizeEvent *event) {
    qDebug() << "Window resized to" << event->size();
}

// 焦点事件示例
void MyWidget::focusInEvent(QFocusEvent *event) {
    qDebug() << "Widget gained focus";
}

void MyWidget::focusOutEvent(QFocusEvent *event) {
    qDebug() << "Widget lost focus";
}
```

以上这些事件都是QT框架提供的用于处理用户交互和应用程序逻辑的重要机制。

# Qt 中有哪些类型的定时器？它们之间有何区别？


Qt 中有三种类型的定时器，它们分别是基于QObject的定时器、基于QTimer的定时器和基于QElapsedTimer的定时器。

基于QObject的定时器：

这种定时器是通过调用startTimer()函数来创建的，它在派生自QObject类的对象中使用。

它通过重载timerEvent()函数来处理定时器事件，实现定时执行特定操作的功能。

基于QTimer的定时器：

QTimer是一个独立的定时器类，可以在任何地方使用。

它通过timeout信号和start()函数来实现定时执行特定操作的功能。

可以通过setSingleShot()函数设置为单次触发，也可以设置为周期性触发。

基于QElapsedTimer的定时器：

这种定时器是用于测量时间间隔的工具，而不是用于触发特定操作。

它通过start()函数开始计时，然后通过elapsed()函数获取经过的时间。

这三种类型的定时器在功能上有所区别，开发者可以根据具体需求来选择使用哪种类型的定时器。例如，如果需要在QObject派生类中处理定时器事件，可以选择基于QObject的定时器；如果需要在任何地方使用独立的定时器功能，可以选择基于QTimer的定时器；如果需要测量时间间隔而不需要触发特定操作，可以选择基于QElapsedTimer的定时器。

# .QT中提供的连接数据库的类和执行sql语句的类分别是什么?

QSqlDatabase类提供了一种连接到数据库的方法，可以使用它来建立和管理数据库连接。它允许你指定要连接的数据库类型（例如MySQL、SQLite等），以及连接的主机、用户名、密码等信息。

QSqlQuery类用于执行SQL查询和操作数据库。它可以执行诸如SELECT、INSERT、UPDATE、DELETE等SQL语句，还可以获取查询结果集中的数据。

# QT中连接数据库或者执行sql语句发生错误时，通过什么方法可以知道错误原因

在QT中，当连接数据库或执行SQL语句发生错误时，可以通过以下方法来知道错误的原因：

异常处理：在连接数据库或执行SQL语句的过程中，可以使用try-catch语句来捕获异常并处理错误。在捕获到异常时，可以通过异常对象的方法来获取错误信息，例如错误代码、错误描述等。这样可以帮助开发人员及时发现问题并进行处理。



错误代码和消息：QT提供了丰富的错误代码和消息来描述不同类型的错误。当连接数据库或执行SQL语句失败时，可以通过相关的错误代码和消息来了解具体的错误原因。开发人员可以根据这些信息来排查和解决问题。



日志记录：在开发过程中，可以通过日志记录的方式将连接数据库或执行SQL语句的过程以及错误信息记录下来。这样可以帮助开发人员在出现问题时进行排查，并且可以追踪问题发生的原因。

# 说一下并发和并行的区别。
并发是指在同一时间段内执行多个任务，这些任务之间可能会交替进行，而不是同时进行。换句话说，并发指的是多个任务在时间上可能会重叠，但实际上只有一个任务在某一时刻被执行。这种情况常见于单核处理器上通过时间片轮转来实现多任务处理，或者在多核处理器上通过多线程来实现并发执行。

并行是指在同一时刻同时执行多个任务，这些任务可以在多个处理器核心或者多台计算机上同时进行。与并发不同的是，并行是真正同时执行多个任务，而不是交替进行。在并行计算中，每个任务都有自己的处理器资源，它们之间相互独立地执行。

# 对于需要并发的密集型一般有哪些？

对于需要并发的密集型应用，通常包括以下几类：

数据库系统：在数据库系统中，有大量的读写操作需要同时进行，例如多个用户同时访问数据库、多个查询操作同时进行等。通过并发处理可以提高数据库系统的效率和吞吐量。

网络服务器：在网络服务器中，需要同时处理大量的网络请求，如处理用户的登录、数据传输、文件下载等。通过并发处理可以有效地响应并处理大量的并发网络请求。

大数据处理：在大数据处理中，需要同时处理大量的数据，如数据的存储、计算、分析等。通过并发处理可以提高大数据处理的效率和速度。

游戏开发：在游戏开发中，需要同时处理多个玩家的操作、游戏逻辑的计算、图形渲染等。通过并发处理可以实现多个玩家之间的互动和实时性。

这些密集型应用通常需要高效地处理大量的并发任务，通过并发处理可以提高系统的性能和效率，满足用户对实时性和高吞吐量的需求。因此，在设计和开发这些类型的应用时，需要充分考虑并发处理的能力和效果。

# 同一台电脑上有个进程使用TCP协议占用了端口8088，另一个进程也是用TCP协议是否可以占用端口8088，如果使用UDP协议是否可以占用端口8088？

如果同一台电脑上已经有一个进程使用TCP协议占用了端口8088，另一个进程也想要使用TCP协议来占用同样的端口8088，那么通常情况下是不可以的。因为每个端口只能被一个进程占用，这是为了避免混乱和冲突。如果另一个进程也需要使用TCP协议，它需要选择一个没有被占用的端口。

另一方面，如果另一个进程想要使用UDP协议来占用端口8088，那么是可以的。UDP协议和TCP协议是不同的传输层协议，它们在使用端口方面没有冲突。每个协议都有自己独立的端口空间，因此可以同时在同一台电脑上使用相同的端口号，只要它们使用的是不同的协议。

# 什么是TCP协议的半连接？

“半连接”通常指的是第二次握手之后的状态，即服务器在收到客户端的SYN请求并发送SYN-ACK响应之后，但在收到客户端的最终ACK之前的状态。在这个阶段，服务器已经知道客户端希望建立连接，但还没有收到客户端的确认，所以连接尚未完全建立。

# 详细描述TCP三次握手过程中，双方套接字状态的变化？


TCP三次握手过程中，客户端和服务器的套接字状态会经历一系列的变化，以确保双方都能确认连接的建立。以下是详细的变化过程：



### 客户端套接字状态变化：



1. **初始状态（CLOSED）**：

  - 客户端套接字初始处于`CLOSED`状态，表示当前没有连接。



2. **第一次握手（SYN）**：

  - 客户端发送一个带有SYN标志的TCP段到服务器，请求建立连接，并指定一个初始序列号（ISN）。

  - 状态变为`SYN_SENT`，表示客户端已经发送了SYN请求，正在等待服务器的响应。



3. **第二次握手（SYN-ACK）**：

  - 客户端收到服务器的SYN-ACK响应后，进入`SYN_RCVD`状态。

  - 此时，客户端已经收到了服务器的SYN和ACK，但还没有发送最终的ACK确认。



4. **第三次握手（ACK）**：

  - 客户端发送最终的ACK确认给服务器后，状态变为`ESTABLISHED`。

  - 此时，TCP连接已经完全建立，客户端和服务器可以开始双向通信。



### 服务器套接字状态变化：



1. **初始状态（LISTEN）**：

  - 服务器套接字初始处于`LISTEN`状态，表示服务器正在监听来自客户端的连接请求。



2. **第一次握手（SYN）**：

  - 服务器收到客户端的SYN请求后，准备发送SYN-ACK响应。

  - 状态变为`SYN_RCVD`，表示服务器已经收到了SYN请求，并准备发送SYN-ACK响应。



3. **第二次握手（SYN-ACK）**：

  - 服务器发送SYN-ACK响应给客户端后，状态仍然是`SYN_RCVD`。

  - 这是因为服务器已经发送了SYN-ACK，但还没有收到客户端的最终ACK确认。



4. **第三次握手（ACK）**：

  - 服务器收到客户端的最终ACK确认后，状态变为`ESTABLISHED`。

  - 此时，TCP连接已经完全建立，服务器可以开始接收和发送数据。



### 总结：



- **客户端**：`CLOSED` -> `SYN_SENT` -> `SYN_RCVD` -> `ESTABLISHED`

- **服务器**：`LISTEN` -> `SYN_RCVD` -> `ESTABLISHED`



在整个三次握手过程中，客户端和服务器的状态变化确保了双方都能确认连接的建立，从而建立起一个可靠的通信通道。这个过程中的任何错误或超时都可能导致连接建立失败，并触发重试或错误处理机制。

# TCP中的面向连接是物理连接还是逻辑连接？

TCP（传输控制协议）中的面向连接是指逻辑连接（Logical Connection），而不是物理连接（Physical Connection）。下面是对TCP面向连接特性的详细解释：



1. **逻辑连接**：

  - 面向连接意味着在数据传输开始之前，必须在通信的两个端点（即客户端和服务器）之间建立一个会话。这个会话是通过三次握手过程建立的，它确保了双方都能发送和接收数据。

  - 这种连接是建立在两个IP地址之间的，通过端口号来区分特定的应用程序或服务。TCP层维护连接状态信息，包括序列号、确认号、窗口大小等，以确保数据的可靠传输。

  - 逻辑连接是虚拟的，因为它是由TCP协议在软件层面上实现的，而不是通过物理线路直接连接的。



2. **物理连接**：

  - 物理连接指的是实际的通信线路，如光纤、双绞线、无线电波等，它们负责传输电信号或光信号。

  - 在TCP/IP模型中，物理连接是由较低层次的协议（如以太网、Wi-Fi、PPP等）管理的，这些协议负责在物理媒介上传输数据帧或包。



3. **TCP连接与物理连接的关系**：

  - TCP的逻辑连接是建立在物理连接之上的。数据包通过物理连接传输，但TCP层为这些数据包提供了额外的控制机制，如分段、重组、确认和重传。

  - 物理连接可能涉及多个中间节点（如路由器、交换机等），而TCP连接则是端到端的，直接关联到应用程序的套接字接口。



4. **为什么使用逻辑连接**：

  - 逻辑连接提供了可靠性、顺序控制、流量控制和拥塞控制等特性，这些都是物理连接不提供的。

  - 逻辑连接允许应用程序在不同的网络技术和物理介质之间进行抽象，使得应用程序不需要关心底层的物理细节。



总结来说，TCP的面向连接特性是指在两个通信端点之间建立一个逻辑上的连接，这个连接由TCP协议在软件层面上管理和维护，而不是指物理层面上的直接连接。

# 网络协议有几层，都是哪些？


网络协议的层次结构通常指的是OSI（Open Systems Interconnection，开放系统互连）模型和TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/互联网协议）模型。这两个模型是网络通信中最为广泛使用的参考模型。

OSI 七层模型

物理层 (Physical Layer)

负责传输原始比特流，定义了物理连接的标准，如电压、接口、电缆标准等。

数据链路层 (Data Link Layer)

负责节点之间的可靠传输，包括帧的封装、错误检测和纠正、流量控制等。

网络层 (Network Layer)

负责数据包的路由选择和转发，确保数据包能够从源地址到达目的地址。

传输层 (Transport Layer)

负责端到端的通信，提供可靠的数据传输服务，如TCP和UDP协议。

会话层 (Session Layer)

负责建立、管理和终止会话，提供会话管理功能。

表示层 (Presentation Layer)

负责数据格式转换、加密和解密等，确保数据在传输过程中的一致性。

应用层 (Application Layer)

直接与用户交互，提供各种网络应用服务，如HTTP、FTP、SMTP等。

TCP/IP 四层模型

应用层 (Application Layer)

与OSI模型的应用层类似，负责提供各种网络应用服务。

传输层 (Transport Layer)

与OSI模型的传输层类似，负责端到端的通信。

网络层 (Internet Layer)

对应于OSI模型的网络层，负责数据包的路由选择和转发。

链路层 (Link Layer)

包括OSI模型的物理层和数据链路层，负责节点之间的物理传输和数据链路的管理。

总结

OSI模型：分为七层，从下到上依次为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

TCP/IP模型：分为四层，从下到上依次为链路层、网络层、传输层和应用层。

理解这些层次结构有助于你更好地理解网络通信的工作原理和各层的功能。如果你有任何具体的问题或需要进一步的解释，欢迎随时提问！

# 我们使用TCP协议收发数据时，为什么要先建立连接？而使用UDP则不需要建立连接就可以直接收发数据？


1. TCP协议为什么需要先建立连接？

TCP（传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过以下步骤来确保数据的可靠传输：

三次握手：

第一次握手：客户端发送一个SYN（同步序列编号）包到服务器，并进入SYN_SEND状态，等待服务器确认。

第二次握手：服务器收到SYN包后，回应一个SYN+ACK（同步序列编号+确认）包，并进入SYN_RECV状态。

第三次握手：客户端收到服务器的SYN+ACK包后，再发送一个ACK（确认）包给服务器，确认连接建立成功，此时客户端和服务器都进入ESTABLISHED状态。

连接管理：

建立连接后，TCP协议会维护一个连接状态，确保数据的顺序性和可靠性。如果在传输过程中出现丢包或错误，TCP会重新发送丢失的数据包，直到接收方确认收到为止。

流量控制：

TCP通过滑动窗口机制来控制数据的传输速率，防止发送方发送过多数据导致接收方无法处理。

拥塞控制：

TCP通过拥塞控制算法（如慢启动、拥塞避免、快速重传和快速恢复）来动态调整发送速率，避免网络拥塞。

2. UDP协议为什么不需要建立连接？

UDP（用户数据报协议） 是一种无连接的、不可靠的、基于数据报的传输层通信协议。它有以下几个特点：

无连接：

UDP不需要建立连接，可以直接发送数据报。这意味着在发送数据之前，不需要进行三次握手等连接建立过程。

不可靠：

UDP不保证数据的顺序性和可靠性。数据报可能会丢失、重复或乱序到达。如果需要这些特性，必须由上层应用自己实现。

低开销：

由于UDP没有连接管理和流量控制等机制，它的开销相对较低，适合对实时性要求较高的应用，如语音通话、视频流等。

总结

TCP 适用于需要可靠传输的应用，如文件传输、电子邮件等。它通过建立连接来确保数据的顺序性和可靠性。

UDP 适用于对实时性要求较高且可以容忍一定程度数据丢失的应用，如在线游戏、语音通话等。它不需要建立连接，因此开销较低。

# 详细说一下你所了解的处理粘包分包的方法是什么？

粘包和分包是网络编程中常见的问题，特别是在使用TCP协议时。以下是一些常见的处理方法：

粘包和分包的原因

粘包：当发送方发送多条消息时，接收方一次性读取了多条消息的数据，导致数据粘在一起。

分包：当发送方发送一条较大的消息时，接收方分多次读取，导致消息被拆分。

处理方法

固定长度消息：

发送方和接收方约定每个消息的固定长度。如果消息长度不足，可以用空字符填充。

优点：实现简单。

缺点：浪费带宽，不适合变长消息。

消息边界标记：

在每个消息的末尾添加特殊的分隔符（如\n）。

接收方通过查找分隔符来确定每个消息的边界。

优点：适合文本数据。

缺点：如果消息内容中包含分隔符，可能会导致解析错误。

消息长度标识：

在消息头部添加一个字段，表示消息的长度。

接收方先读取消息长度，然后根据长度读取完整的消息。

优点：灵活，适合变长消息。

缺点：增加了额外的开销。

自定义协议：

设计自定义的应用层协议，明确定义消息的格式和边界。

优点：灵活，适合复杂场景。

缺点：实现复杂，需要额外的协议解析逻辑。

这些方法可以有效地解决粘包和分包问题，确保数据传输的完整性和可靠性

# 说一下使用TCP协议时，为什么需要处理粘包和分包

在使用TCP协议时，处理粘包和分包问题是非常重要的。以下是原因和解决方案的详细解释：

粘包和分包的原因

粘包：

定义：粘包是指多个小的数据包在传输过程中被合并成一个大包发送。

原因：TCP是面向流的协议，没有明确的消息边界。当发送方发送的数据量较小且间隔时间短，TCP会将这些小数据包合并成一个大包发送，以提高传输效率1。

分包：

定义：分包是指一个大的数据包在传输过程中被拆分成多个小包发送。

原因：当发送方发送的数据量超过了TCP缓冲区的大小，TCP会将这个大包拆分成多个小包进行传输2。

解决方案

固定数据大小：

方法：将每个数据包固定为一个特定的大小（例如1024字节）。如果数据不足这个大小，可以通过填充空格或其他字符来补全。

优点：简单易行，适用于数据长度固定的场景。

使用分隔符：

方法：在每个数据包的末尾添加一个固定的分隔符（例如\r\n）。接收方在接收到数据后，通过分隔符来区分不同的数据包。

优点：适用于文本数据传输，常用于FTP协议等1。

消息头部包含长度信息：

方法：将消息分为头部和消息体，头部包含整个消息的长度信息。接收方在读取到足够长度的数据后，认为接收到一个完整的消息。

优点：适用于自定义协议，能够准确地处理粘包和分包问题。

自定义协议：

方法：根据具体应用场景设计自定义协议，明确消息的边界和格式。

优点：灵活性高，能够根据需求进行调整2。

通过这些方法，可以有效地处理TCP协议中的粘包和分包问题，确保数据传输的准确性和可靠性。

# 说一下你所了解的应用层的流媒体协议有哪些？


应用层的流媒体协议有很多种，常见的包括以下几种：

RTSP (Real-Time Streaming Protocol)：实时流式协议，主要用于控制多媒体流的传输，如播放、暂停、快进等。RTSP本身不传输数据，实际的数据传输通常使用RTP1。

RTP (Real-Time Transport Protocol)：实时传输协议，负责在网络上传输音视频数据。RTP通常与RTCP（RTP Control Protocol）一起使用，RTCP负责监控传输质量和同步多媒体数据1。

RTMP (Real-Time Messaging Protocol)：实时消息传输协议，由Adobe开发，主要用于Flash播放器和服务器之间的音视频数据传输。RTMP基于TCP协议，能够保持长连接并提供低延时通信2。

HLS (HTTP Live Streaming)：由Apple提出的基于HTTP的流媒体传输协议，将媒体流切割成小块，通过HTTP下载并播放。HLS具有良好的网络兼容性，能够穿透防火墙2。

WebRTC (Web Real-Time Communication)：用于浏览器之间的实时通信协议，支持音视频流的直接传输，常用于视频会议和实时聊天应用1。

这些协议各有特点，选择使用哪种协议通常取决于具体的应用场景和需求。

1: 流媒体协议详解 2: 流媒体协议RTP、RTSP、RTMP、HLS、SRT、WebRTC全面分析

# 说一下你所了解的应用层协议有哪些？

应用层协议是网络通信中最高层的协议，负责定义应用程序之间的通信规则，使不同设备和应用能够有效地交换信息。以下是一些常见的应用层协议：

HTTP/HTTPS（超文本传输协议）：

用于传输浏览器使用的普通文本、超文本、音频和视频等数据。

HTTPS 是 HTTP 的安全版本，通过 SSL/TLS 加密数据传输。

SMTP/POP3/IMAP（邮件协议）：

SMTP（简单邮件传输协议）：用于发送电子邮件。

POP3（邮局协议第3版）：用于从邮件服务器下载邮件。

IMAP（互联网邮件访问协议）：允许用户在多个设备上同步邮件。

FTP（文件传输协议）：

用于在客户机与服务器之间进行文件传输。

支持用户登录认证和访问权限控制。

DNS（域名系统）：

将域名解析为 IP 地址，使用户能够更方便地访问互联网。

SSH（安全外壳协议）：

为远程登录会话和其他网络服务提供安全性。

通过加密防止信息泄露。

Telnet：

用于远程登录到服务器，执行命令。

由于安全性问题，逐渐被 SSH 取代。

DHCP（动态主机配置协议）：

自动分配 IP 地址，简化网络管理。

NTP（网络时间协议）：

用于同步网络中各计算机的时间。

SNMP（简单网络管理协议）：

用于管理和监控网络设备。

这些协议在不同的应用场景中发挥着重要作用，确保网络通信的顺畅和安全123。

如果你有任何具体的应用场景或协议想要深入了解，随时告诉我！

1: 常见应用层协议_应用层协议有哪些-CSDN博客 2: 应用层协议详解 - 知乎 3: 应用层常见的协议有哪些？ - 阿里云开发者社区

# windows下都有哪些异步网络模型？

在Windows操作系统下，有几种常见的异步网络模型：

重叠I/O（Overlapped I/O）：这是Windows中最常用的异步I/O模型之一。通过使用OVERLAPPED结构和相关的API函数（如ReadFile、WriteFile等），应用程序可以在不阻塞线程的情况下执行I/O操作。

I/O完成端口（I/O Completion Ports, IOCP）：这是一个高效的异步I/O模型，适用于需要处理大量并发I/O操作的应用程序。通过创建一个I/O完成端口并将其与多个I/O操作关联，系统可以在I/O操作完成时通知应用程序，从而提高性能和可扩展性。

异步套接字（Asynchronous Sockets）：使用Windows套接字API（Winsock）提供的异步操作函数（如WSARecv、WSASend等），可以实现非阻塞的网络通信。这种方法适用于需要处理网络I/O的应用程序。

事件驱动I/O（Event-Driven I/O）：通过使用事件对象（Event Objects）和相关的API函数（如WaitForSingleObject、WaitForMultipleObjects等），应用程序可以在I/O操作完成时接收通知。这种方法适用于需要等待多个I/O操作完成的场景。

这些异步网络模型各有优缺点，开发者可以根据具体需求选择合适的模型来实现高效的异步网络通信。

# QT的QTcpServer使用的是哪个网络模型？
QT 的 QTcpServer 使用的是 select 模型。这个模型在 Windows 下使用，而在 Linux 下的新版本改为了 poll 模型。

总的来说，QTcpServer 是 Qt 网络模块中的一个关键类，用于创建 TCP 服务器。它负责监听指定的端口，等待客户端的连接请求。当有客户端连接时，服务器会创建一个新的 QTcpSocket 实例来处理这个连接。这样，你可以轻松地构建基于 TCP 的服务器应用程序1.

# 说一下你所了解的IO多路复用网络模型都有哪些？

IO多路复用（Input/Output Multiplexing）是一种在单个线程中管理多个输入/输出通道的技术。它允许一个线程同时监听多个输入流（例如网络套接字、文件描述符等），并在有数据可读或可写时进行相应的处理，而不需要为每个通道创建一个独立的线程。常见的IO多路复用机制包括以下几种：

select模型：

使用一个文件描述符集合来监听多个IO事件的就绪状态。

需要将需要监听的文件描述符添加到集合中，然后调用select函数进行监听。

一旦有文件描述符就绪，select函数会返回，并告知哪些文件描述符已经准备好进行读取或写入操作。

缺点：需要遍历所有文件描述符，时间复杂度为O(N)。

poll模型：

类似于select，但使用一个pollfd结构体数组来传递需要监听的文件描述符和事件类型。

通过调用poll函数进行监听，一旦有文件描述符就绪，会返回相应信息。

优点：相对于select，不需要每次传递文件描述符集合，更灵活。

epoll模型：

是Linux特有的IO多路复用机制。

使用一个内核事件表来管理和监听多个IO事件的就绪状态。

应用程序将需要监听的文件描述符添加到内核事件表中，然后调用epoll_wait函数进行监听。

一旦有文件描述符就绪，epoll_wait函数会返回，并告知哪些文件描述符已经准备好进行读取或写入操作。

优点：不需要遍历所有文件描述符，只需管理活跃的连接，时间复杂度为O(1)。

Reactor模型：

主从Reactor多线程模型，包括一个主Reactor和多个从Reactor。

主Reactor负责响应客户端连接事件，从Reactor处理其他事件。

适用于高并发的服务器应用。

总之，IO多路复用适用于需要同时管理和处理多个IO通道的场景，特别是在需要高并发处理的网络编程和服务器应用中非常常见。它可以提高系统的性能和资源利用率，简化编程模型，并具有良好的可扩展性

# 描述一下你所理解的TCP协议的三次握手

TCP协议的三次握手是建立一个可靠的连接的过程。这个过程确保了双方在开始传输数据之前已经准备好，并且能够相互确认对方的存在和状态。下面是详细的步骤和解释：

1. 第一次握手（SYN）

客户端向服务器发送一个带有SYN（同步序列编号）标志的数据包。

这个数据包包含一个初始序列号（ISN），表示客户端希望从这个序列号开始发送数据。

客户端进入SYN_SENT状态。

2. 第二次握手（SYN + ACK）

服务器收到客户端的SYN数据包后，会回应一个带有SYN和ACK（确认）标志的数据包。

服务器的响应数据包包含两个序列号：

一个是对客户端ISN的确认（ACK = ISN + 1），表示服务器收到了客户端的初始序列号。

另一个是服务器自己的初始序列号（ISN），表示服务器希望从这个序列号开始发送数据。

服务器进入SYN_RCVD状态。

3. 第三次握手（ACK）

客户端收到服务器的SYN + ACK数据包后，会回应一个带有ACK标志的数据包。

这个数据包包含对服务器ISN的确认（ACK = ISN + 1），表示客户端收到了服务器的初始序列号。

客户端进入ESTABLISHED状态。

服务器收到客户端的ACK数据包后，也进入ESTABLISHED状态。

为什么需要三次握手？

防止已失效的连接请求报文段突然又传送到服务器，造成错误：

如果只有两次握手，客户端发送的SYN数据包在网络中延迟后再次到达服务器，服务器可能会误以为这是一个新的连接请求，从而导致不必要的资源消耗。

三次握手确保了双方都确认了对方的存在和状态，避免了这种情况。

双向确认：

第一次握手：客户端确认自己可以发送数据。

第二次握手：服务器确认自己可以接收数据，并且确认了客户端的存在。

第三次握手：客户端确认自己可以接收数据，并且确认了服务器的存在。

图解

客户端                             服务器

  |                                    |

  |  SYN (ISN)                         |

  |  --------------------------------> |

  |                                    |

  |  <-------------------------------  |

  |  SYN + ACK (ISN+1, ISN')           |

  |                                    |

  |  ACK (ISN'+1)                      |

  |  --------------------------------> |

  |                                    |

  |  (ESTABLISHED)                     |

  |                                    |

  |  (ESTABLISHED)                     |

  |                                    |

总结

TCP协议的三次握手确保了双方在开始传输数据之前已经建立了可靠的连接。通过这三次握手，客户端和服务器都确认了对方的存在和状态，避免了因网络延迟或其他原因导致的错误连接。希望这些解释能帮助你更好地理解TCP协议的三次握手过程。

# 详细说一下你所了解的处理粘包分包的方法是什么？

好的，处理粘包和分包是网络编程中常见的问题。在使用Qt进行网络编程时，可以采用以下几种方法来处理粘包和分包问题。

粘包和分包问题概述

粘包：多个数据包被合并成一个数据包发送。

分包：一个完整的数据包被拆分成多个数据包发送。

处理方法

1. 固定长度的消息

原理：每条消息都有固定的长度，接收方根据固定长度来读取数据。

实现步骤：

发送方将每条消息填充到固定长度。

接收方每次读取固定长度的数据，直到读取完整个消息。

示例代码：

cpp

// 发送方

void sendFixedLengthMessage(QTcpSocket *socket, const QByteArray &message) {

    QByteArray fixedMessage = message.leftJustified(1024, ' '); // 假设固定长度为1024字节

    socket->write(fixedMessage);

}



// 接收方

void readFixedLengthMessage(QTcpSocket *socket) {

    while (socket->bytesAvailable() >= 1024) { // 每次读取1024字节

        QByteArray message = socket->read(1024);

        // 处理消息

    }

}

2. 带消息头的消息

原理：每条消息包含一个消息头，消息头中包含消息的实际长度，接收方根据消息头中的长度来读取数据。

实现步骤：

发送方先发送消息头（包含消息长度），再发送消息体。

接收方先读取消息头，解析出消息长度，然后根据消息长度读取消息体。

示例代码：

cpp

// 发送方

void sendMessageWithHeader(QTcpSocket *socket, const QByteArray &message) {

    QByteArray header = QByteArray::number(message.size()).rightJustified(4, '0'); // 假设消息头长度为4字节

    socket->write(header + message);

}



// 接收方

void readMessageWithHeader(QTcpSocket *socket) {

    while (socket->bytesAvailable() >= 4) { // 先读取消息头

        QByteArray header = socket->read(4);

        int messageSize = header.toInt();

        if (socket->bytesAvailable() >= messageSize) { // 确保消息体已经到达

            QByteArray message = socket->read(messageSize);

            // 处理消息

        }

    }

}

3. 特殊分隔符

原理：每条消息之间用特殊的分隔符（如换行符 \n）分隔，接收方根据分隔符来分割消息。

实现步骤：

发送方在每条消息末尾添加分隔符。

接收方读取所有可用数据，然后根据分隔符分割消息。

示例代码：

cpp

// 发送方

void sendMessageWithDelimiter(QTcpSocket *socket, const QByteArray &message) {

    socket->write(message + "\n");

}



// 接收方

void readMessageWithDelimiter(QTcpSocket *socket) {

    while (socket->bytesAvailable()) {

        QByteArray data = socket->readAll();

        QList<QByteArray> messages = data.split('\n');

        for (const QByteArray &message : messages) {

            if (!message.isEmpty()) {

                // 处理消息

            }

        }

    }

}

总结

以上三种方法都可以有效处理粘包和分包问题，具体选择哪种方法取决于你的应用场景和需求。固定长度的消息适用于消息长度固定且不大的场景；带消息头的消息适用于消息长度不固定但需要精确控制的情况；特殊分隔符的方法适用于消息内容较为简单且可以使用分隔符区分的情况。

# 详细描述TCP三次握手过程中，双方套接字状态的变化？
好的，TCP三次握手是建立TCP连接的过程。在这个过程中，双方套接字的状态会发生变化。下面详细描述这个过程：

TCP三次握手过程

第一次握手：客户端发送SYN请求

客户端状态变化：从CLOSED变为SYN_SENT。

服务器状态变化：无变化，仍为CLOSED。

第二次握手：服务器响应SYN+ACK

客户端状态变化：无变化，仍为SYN_SENT。

服务器状态变化：从CLOSED变为SYN_RCVD。

第三次握手：客户端发送ACK确认

客户端状态变化：从SYN_SENT变为ESTABLISHED。

服务器状态变化：从SYN_RCVD变为ESTABLISHED。

详细状态变化

客户端状态变化

初始状态：CLOSED（关闭状态）

第一次握手后：SYN_SENT（已发送SYN同步请求）

第三次握手后：ESTABLISHED（连接已建立）

服务器状态变化

初始状态：CLOSED（关闭状态）

第二次握手后：SYN_RCVD（已接收SYN同步请求）

第三次握手后：ESTABLISHED（连接已建立）

图解

客户端                      服务器

CLOSED -----------------------> CLOSED

     | (发送SYN)

     v

SYN_SENT <------------------- SYN_RCVD

     | (接收SYN+ACK)

     v

SYN_SENT -------------------> ESTABLISHED

     | (发送ACK)

     v

ESTABLISHED <---------------- ESTABLISHED

解释

第一次握手：

客户端发送一个带有SYN标志的TCP段，表示请求建立连接。

客户端的状态从CLOSED变为SYN_SENT，表示已发送SYN同步请求，等待服务器的响应。

第二次握手：

服务器收到客户端的SYN请求后，发送一个带有SYN和ACK标志的TCP段作为响应。

服务器的状态从CLOSED变为SYN_RCVD，表示已接收SYN同步请求，等待客户端的最终确认。

第三次握手：

客户端收到服务器的SYN+ACK响应后，发送一个带有ACK标志的TCP段作为确认。

客户端的状态从SYN_SENT变为ESTABLISHED，表示连接已建立。

服务器收到客户端的ACK确认后，状态从SYN_RCVD变为ESTABLISHED，表示连接已建立。

通过这三次握手，客户端和服务器之间的TCP连接就成功建立了。希望这些解释能帮助你更好地理解TCP三次握手过程中双方套接字状态的变化。如果有任何疑问，欢迎继续提问。

# windows下都有哪些异步网络模型？

在Windows操作系统中，有几种常用的异步网络模型，这些模型允许应用程序在执行其他任务的同时处理网络通信。以下是主要的异步网络模型：



重叠I/O (Overlapped I/O)



描述：重叠I/O 是一种基于事件的异步I/O机制。应用程序可以发起一个I/O操作，并继续执行其他任务，当I/O操作完成时，系统会通知应用程序。

实现方式：使用 WSASend 和 WSARecv 函数，配合 OVERLAPPED 结构体和 GetQueuedCompletionStatus 函数来处理完成通知。

优点：灵活且高效，适用于高性能服务器。

缺点：实现复杂，需要管理多个线程和完成端口。

完成端口 (I/O Completion Ports)



描述：完成端口是一种高级的异步I/O机制，它允许多个线程共享一个或多个I/O完成队列。当I/O操作完成时，系统会将完成信息放入队列中，线程可以从队列中取出并处理这些信息。

实现方式：使用 CreateIoCompletionPort 创建完成端口，然后将文件句柄、套接字等与完成端口关联起来。使用 PostQueuedCompletionStatus 和 GetQueuedCompletionStatus 处理完成通知。

优点：高度可扩展，适用于高并发场景。

缺点：实现较为复杂，需要对多线程编程有深入理解。

异步选择性 I/O (Asynchronous Selective I/O)



描述：这种模型使用 select 函数来监控多个套接字的状态变化。当某个套接字准备好进行读写操作时，select 会返回，应用程序可以进行相应的处理。

实现方式：使用 select 函数，结合 FD_SET、FD_ISSET 等宏来管理套接字集合。

优点：简单易用，适合小型应用。

缺点：性能较低，不适用于大量套接字的高并发场景。

事件选择 (Event Select)



描述：这种模型使用 WSAEventSelect 函数将套接字与事件对象关联起来。当套接字的状态发生变化时，事件对象会被触发，应用程序可以通过等待事件对象来处理这些变化。

实现方式：使用 WSAEventSelect 函数注册感兴趣的事件类型，使用 WaitForMultipleObjects 等函数等待事件对象。

优点：比 select 更高效，适用于中等规模的应用。

缺点：仍然存在一定的性能瓶颈，不如完成端口灵活。

异步套接字 (Asynchronous Sockets)



描述：这种模型使用 WSAAsyncSelect 函数将套接字与窗口消息队列关联起来。当套接字的状态发生变化时，系统会发送一个消息到指定的窗口，应用程序可以在窗口过程函数中处理这些消息。

实现方式：使用 WSAAsyncSelect 函数注册感兴趣的事件类型，处理窗口消息。

优点：适用于基于窗口的应用程序，实现简单。

缺点：依赖于窗口消息队列，不适合无界面的应用程序。

每种模型都有其适用的场景和优缺点，选择合适的模型取决于具体的应用需求和性能要求。希望这些信息对你有所帮助！如果你有任何进一步的问题，欢迎随时提问。

# QT的QTcpServer使用的是哪个网络模型？

QT的QTcpServer使用的是事件驱动的异步网络模型。

详细解释

事件驱动：

QTcpServer是Qt框架中的一个类，用于监听传入的TCP连接请求。当有新的连接请求时，QTcpServer会触发一个信号（newConnection()），通知应用程序有新的客户端连接。

这种机制是典型的事件驱动模型，即应用程序不需要主动轮询是否有新的连接请求，而是通过事件机制被动地接收通知。

异步：

在事件驱动的基础上，QTcpServer的处理方式是异步的。这意味着当新的连接请求到达时，QTcpServer不会阻塞当前的执行流程，而是通过信号和槽机制将处理任务传递给应用程序。

应用程序可以在槽函数中处理新的连接，例如创建一个新的QTcpSocket对象来管理这个连接，而不会影响其他部分的正常运行。

# 什么是多态，多态的作用？
在 C++ 中，多态（Polymorphism）是面向对象编程的重要特性之一。



多态分为静态多态和动态多态。静态多态通常通过函数重载和模板来实现，在编译时就能确定要调用的具体函数。



动态多态则通过虚函数来实现，在运行时根据对象的实际类型来确定要调用的函数版本。



多态的主要作用包括：



1. 提高代码的可扩展性和可维护性：通过多态，可以在不修改现有代码的基础上，添加新的子类和实现，实现对功能的扩展。



2. 增强代码的灵活性：可以使用父类指针或引用来操作不同的子类对象，而无需关心具体的子类类型，提高了代码的通用性。



3. 改善代码的结构：使代码的组织更加清晰，不同的类可以专注于自己特定的实现，而通过共同的父类接口进行交互。



例如，有一个父类 `Shape` 和它的子类 `Circle` 、 `Rectangle` ，可以定义一个父类的指针或引用，通过这个指针或引用调用虚函数 `draw` 时，实际调用的是具体子类的 `draw` 实现，从而实现了多态。

# C++中vector和list 的区别?
在 C++ 中，`vector` 和 `list` 主要有以下区别：



1. 内存存储方式：

    - `vector` 采用连续的内存存储，类似于数组，这使得随机访问元素的速度很快，但在插入和删除元素时，如果涉及到内存重新分配和元素移动，可能会有较大的性能开销。

    - `list` 采用链表结构存储，内存不是连续的。插入和删除元素的操作效率高，只需修改指针，但随机访问元素的效率较低。



2. 随机访问效率：

    - `vector` 支持高效的随机访问，通过索引可以在常量时间内访问元素。

    - `list` 不支持随机访问，访问一个元素需要从链表头开始顺序遍历，时间复杂度为线性。



3. 插入和删除操作：

    - 在 `vector` 的中间位置插入或删除元素，可能导致大量元素的移动，效率较低。在末尾插入元素，如果不需要重新分配内存，则效率较高。

    - 在 `list` 的任何位置进行插入和删除操作，效率都比较高，只需修改几个指针。



4. 内存分配策略：

    - `vector` 当容量不足时，会重新分配一块更大的连续内存，并将原有的元素复制过去。

    - `list` 每次插入新元素时，只需分配一个新节点的内存。



5. 遍历方式：

    - `vector` 适合使用迭代器或索引进行遍历。

    - `list` 只能通过迭代器顺序遍历。



综上所述，选择使用 `vector` 还是 `list` 取决于具体的应用场景和操作需求。如果需要频繁随机访问，并且插入删除操作主要在末尾进行，`vector` 可能更合适；如果插入删除操作频繁且位置不固定，`list` 则更具优势。

# 简述STL 中的 allocator, deallocator?
在 C++ 的标准模板库（STL）中：



`allocator`（分配器）：负责内存的分配和初始化。它为容器提供了获取内存来存储元素的方式。不同的 `allocator` 实现可以采用不同的策略来管理内存，以满足特定的性能和需求。



`deallocator`（释放器）：与 `allocator` 相对应，负责释放由 `allocator` 分配的内存。



通过使用 `allocator` 和 `deallocator` ，STL 容器可以灵活地控制内存的获取和释放，使其能够适应不同的内存管理策略和环境。通常，在大多数情况下，我们使用默认的 `allocator` 就能够满足需求，无需显式地处理它们。但在一些特殊的场景，例如需要自定义内存管理策略、优化内存使用或处理特定的内存环境时，可能会自定义 `allocator` 和 `deallocator` 。

# C++11标准的新特性有哪些？

C++11 引入了许多新特性，以下是一些主要的新特性：



1. 智能指针：`unique_ptr`、`shared_ptr` 和 `weak_ptr` 用于更安全和方便的内存管理。

2. 初始化列表：可以更简洁地初始化对象和容器。

3. `auto` 和 `decltype` 关键字：用于自动类型推导。

4. 范围 `for` 循环：更方便地遍历容器。

5. 右值引用和移动语义：提高性能，尤其是在对象的复制和移动操作上。

6.  lambdas 表达式（匿名函数）：使函数式编程更方便。

7.  constexpr ：用于在编译时计算常量表达式。

8. 强类型枚举（`enum class`）：增强了类型安全性。

9. 委托构造函数：一个构造函数可以调用另一个构造函数来完成初始化工作。

10. 空指针常量 `nullptr` ：替代 `NULL` ，类型更安全。

# 简述STL中的hash_map扩容发生什么?
在 STL 中，`hash_map`（更准确地说是 `unordered_map` ）的扩容通常会发生以下情况：



1. 重新计算哈希值：当容器需要扩容时，会重新计算所有已存储元素的哈希值。

2. 增加桶的数量：桶的数量通常会增加，以降低哈希冲突的概率。

3. 元素重新分布：根据新的哈希值和桶数量，元素会被重新分布到新的桶中。



扩容操作是一个相对较耗时的过程，因为涉及到大量的计算和元素的重新调整。为了减少扩容的频率，`unordered_map` 通常会在负载因子（元素数量与桶数量的比值）达到一定阈值时才进行扩容。

# STL 中 List 与 Queue之间的区别?
在 C++ 的 STL 中，`List`（通常指 `std::list` ）和 `Queue`（通常指 `std::queue` ）有以下一些区别：



1. 数据结构：

    - `std::list` 是双向链表，允许在链表的任何位置进行高效的插入和删除操作。

    - `std::queue` 是一种先进先出（FIFO）的数据结构，通常基于其他容器（如 `deque` 或 `list` ）实现。



2. 访问元素方式：

    - 在 `std::list` 中，可以通过迭代器遍历并访问任意位置的元素。

    - `std::queue` 只允许访问队头和队尾的元素，不支持直接访问中间的元素。



3. 插入和删除操作：

    - `std::list` 在任何位置插入和删除元素的效率都较高。

    - `std::queue` 只能在队尾插入元素，在队头删除元素。



4. 迭代器支持：

    - `std::list` 提供双向迭代器。

    - `std::queue` 不提供迭代器用于遍历元素。



5. 用途：

    - `std::list` 适用于需要频繁插入和删除元素，且位置不固定的场景。

    - `std::queue` 主要用于实现队列这种特定的逻辑，如任务队列、消息队列等。



综上所述，`std::list` 更注重灵活的元素操作，而 `std::queue` 则专注于实现先进先出的队列行为。

# STL中map和set的工作原理?

在 C++ 的 STL 中，map 和 set 通常都是基于红黑树实现的。





红黑树是一种自平衡的二叉搜索树，具有以下特点和性质：





每个节点要么是红色，要么是黑色。

根节点是黑色的。

每个叶子节点（NIL 节点）是黑色的。

如果一个节点是红色的，那么它的两个子节点都是黑色的。

从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。



set 的工作原理：

set 中的元素是唯一的。当向 set 中插入元素时，红黑树会根据元素的值确定其在树中的位置，并进行插入操作。如果插入的元素已经存在，则不会进行重复插入。查找元素时，通过比较要查找的值与树中节点的值，按照二叉搜索树的规则进行查找，时间复杂度为 O (log n)，其中 n 是 set 中元素的数量。



map 的工作原理：

map 存储的是键值对。键具有唯一性。插入键值对时，根据键的值确定其在红黑树中的位置，并插入节点。查找时，根据给定的键进行查找，获取对应的值。同样，时间复杂度为 O (log n)。



红黑树的自平衡性质保证了插入、删除和查找操作在平均和最坏情况下都能保持较好的性能。

# 什么是程序, 什么是进程？进程的调度策略有几种方式?
程序是一些指令的有序集合，而进程是程序执行的过程，进程是程序的一次执行过程。

进程的状态是变化的，其包括进程的创建、调度和消亡。

只要程序运行，此时就是进程，程序每运行一次，就会创建一个进程

1. 先来先服务（First-Come, First-Served, FCFS）

描述：按照进程到达的顺序进行调度。

优点：实现简单。

缺点：可能导致长进程占用 CPU 时间过长，影响短进程的响应时间。

2. 短作业优先（Shortest Job First, SJF）

描述：优先调度预计运行时间最短的进程。

优点：平均等待时间较短。

缺点：难以准确预测每个进程的运行时间，可能导致长进程长时间得不到调度。

3. 优先级调度（Priority Scheduling）

描述：根据进程的优先级进行调度，优先级高的进程优先执行。

优点：可以根据任务的重要性和紧急性进行调度。

缺点：低优先级的进程可能长时间得不到调度，导致“饥饿”现象。

4. 轮转法（Round Robin, RR）

描述：将 CPU 时间分成固定长度的时间片（Time Slice），每个进程轮流执行一个时间片。

优点：保证了所有进程都能得到 CPU 时间，提高了系统的响应性。

缺点：上下文切换频繁，可能会增加系统开销。

5. 多级反馈队列调度（Multilevel Feedback Queue Scheduling）

描述：结合了多种调度策略，将进程分为多个优先级队列，每个队列采用不同的调度算法。

优点：灵活性高，可以根据进程的行为动态调整优先级。

缺点：实现复杂，管理成本较高。

6. 抢占式调度（Preemptive Scheduling）

描述：允许操作系统在某个进程执行过程中中断该进程，将 CPU 分配给其他进程。

优点：提高了系统的响应性和公平性。

缺点：增加了上下文切换的开销。

# 描述C++中的STL（标准模板库）及其主要组件。
C++标准模板库（STL）是C++标准库的一部分，它提供了一组通用的模板类和函数，用于处理各种数据结构和算法。STL的设计目标是提供一种高效、可重用和泛型的方式来处理数据集合。以下是STL的主要组件：



1. **容器（Containers）**：

  - `vector`：动态数组，支持快速随机访问。

  - `list`：双向链表，支持快速插入和删除。

  - `deque`：双端队列，支持快速的首尾插入和删除。

  - `set`：基于红黑树的集合，元素唯一，自动排序。

  - `map`：基于红黑树的键值对集合，键唯一，自动排序。

  - `unordered_set`：基于哈希表的集合，元素唯一，无序。

  - `unordered_map`：基于哈希表的键值对集合，键唯一，无序。

  - `stack`、`queue`、`priority_queue`：这些是容器适配器，提供特定的数据结构操作。



2. **迭代器（Iterators）**：

  - 迭代器是STL中用于遍历容器元素的对象。它们提供了一种统一的接口来访问容器中的元素，而不需要知道容器的内部实现。

  - 迭代器可以分为输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器等。



3. **算法（Algorithms）**：

  - STL提供了大量的算法，如排序、搜索、变换、算术运算等。

  - 常见的算法包括：`sort`、`search`、`copy`、`transform`、`accumulate`等。

  - 这些算法都是模板函数，可以作用于任何类型的容器和迭代器。



4. **函数对象（Functors）/ 谓词（Predicates）**：

  - 函数对象是重载了函数调用操作符（`operator()`）的类，它们可以像函数一样被调用。

  - 谓词是返回布尔值的函数对象，常用于算法中作为条件判断，例如在`find_if`或`remove_if`中。



5. **配接器（Adaptors）**：

  - 配接器是一种特殊的容器，它们可以改变容器的行为，例如`stack`、`queue`和`priority_queue`。

  - 还有一些迭代器配接器，如`reverse_iterator`、`insert_iterator`、`back_insert_iterator`等。



6. **分配器（Allocators）**：

  - 分配器是管理内存分配和释放的模板类。STL容器使用分配器来分配和管理它们所需的内存。

  - 用户可以定义自己的分配器来满足特定的内存管理需求。



STL的设计哲学是“不要支付你不需要的东西”，这意味着STL组件在提供强大功能的同时，也保持了灵活性和效率。STL的泛型编程特性使得代码更加简洁和可重用，同时也提高了代码的可维护性。

# 虚函数和纯虚函数的区别什么?
在C++中，虚函数（virtual function）和纯虚函数（pure virtual function）是多态性（polymorphism）的两个重要概念，它们的主要区别如下：



1. **定义方式**：

  - **虚函数**：在基类中使用`virtual`关键字声明的函数。

   ```cpp

   class Base {

   public:

     virtual void func() {

       // 实现

     }

   };

   ```

  - **纯虚函数**：在基类中使用`virtual`关键字后跟`= 0`声明的函数。

   ```cpp

   class Base {

   public:

     virtual void func() = 0;

   };

   ```



2. **强制性质**：

  - **虚函数**：不是强制要求派生类去实现它，派生类可以选择不覆盖基类中的虚函数，直接使用基类的实现。

  - **纯虚函数**：强制要求派生类去实现它，如果派生类没有实现纯虚函数，那么派生类也会变成抽象类，不能实例化。



3. **目的和用途**：

  - **虚函数**：用于实现多态性，允许在基类指针或引用上调用派生类的实现，以实现动态绑定。

  - **纯虚函数**：用于强制派生类提供特定的接口实现，确保所有派生类都遵循相同的接口规范。



4. **抽象类**：

  - 包含纯虚函数的类被称为抽象类，不能被直接实例化。

  - 包含虚函数的类不一定是抽象类，除非它也包含纯虚函数。



5. **接口定义**：

  - **虚函数**：可以用于定义接口的一部分，也可以提供默认实现。

  - **纯虚函数**：专门用于定义接口，不提供任何实现，要求派生类必须实现。



6. **派生类中的实现**：

  - **虚函数**：派生类可以覆盖基类的虚函数，也可以选择不覆盖，直接继承基类的实现。

  - **纯虚函数**：派生类必须覆盖基类的纯虚函数，否则派生类也会变成抽象类。



总结来说，虚函数提供了一种实现多态的方式，允许派生类根据需要覆盖基类的实现；而纯虚函数则是一种强制机制，确保所有派生类都实现特定的接口，常用于接口类或抽象类的定义。

# 智能指针有哪几种类型，有什么特点
在C++中，智能指针是用于自动管理动态分配（使用`new`关键字）的内存的一种方式，以防止内存泄漏。C++11引入了几种智能指针类型，它们位于`<memory>`头文件中。以下是几种主要的智能指针类型及其特点：



1. **std::unique_ptr**：

  - **特点**：提供了独占所有权模型，意味着同一时间只能有一个`std::unique_ptr`指向特定资源。

  - **用法**：当你需要确保一个资源只有一个所有者时使用。

  - **限制**：不能被复制（Copy Constructor和Copy Assignment Operator被删除），只能被移动（Move Constructor和Move Assignment Operator可用）。



2. **std::shared_ptr**：

  - **特点**：使用引用计数机制来管理资源的生命周期。多个`std::shared_ptr`可以指向同一个资源，当最后一个引用被销毁时，资源会被释放。

  - **用法**：当你需要多个所有者共享同一个资源时使用。

  - **性能**：由于需要维护引用计数，所以比`std::unique_ptr`有更高的开销。



3. **std::weak_ptr**：

  - **特点**：是一种不控制对象生命周期的智能指针，用于解决`std::shared_ptr`相互引用时可能产生的循环引用问题。

  - **用法**：通常与`std::shared_ptr`一起使用，用于打破强引用环。

  - **限制**：不能直接访问资源，需要先转换为`std::shared_ptr`。



4. **std::auto_ptr**（已废弃）：

  - **特点**：在C++11之前用于自动管理指针，它会自动转移所有权。

  - **限制**：在C++11中被标记为废弃，并在C++17中被移除。不建议使用，应改用`std::unique_ptr`。



5. **std::scoped_ptr**（已废弃）：

  - **特点**：是`std::unique_ptr`的早期版本，用于自动管理指针，当`std::scoped_ptr`离开作用域时自动释放资源。

  - **限制**：在C++11中被`std::unique_ptr`取代，不建议使用。



智能指针的使用可以帮助开发者减少内存泄漏的风险，但是它们也有自己的适用场景和性能考量。在实际编程中，应根据具体需求选择合适的智能指针类型。

# tcp与udp协议的区别?

TCP（传输控制协议）和UDP（用户数据报协议）是两种常用的网络传输层协议，它们在网络通信中扮演着重要的角色。以下是它们的主要区别：



1. **连接性**：

  - **TCP**：是一种面向连接的协议，数据传输前必须建立连接，确保数据的可靠传输。

  - **UDP**：是一种无连接的协议，数据传输前不需要建立连接，直接发送数据。



2. **数据传输**：

  - **TCP**：提供可靠的数据传输服务，确保数据按顺序、无差错、不重复地到达。

  - **UDP**：不保证数据的可靠传输，数据可能会丢失、重复或乱序到达。



3. **拥塞控制和流量控制**：

  - **TCP**：有拥塞控制和流量控制机制，可以根据网络状况调整数据传输速率。

  - **UDP**：没有拥塞控制和流量控制，发送速率由应用程序控制。



4. **速度**：

  - **TCP**：由于需要确认和重传机制，速度相对较慢。

  - **UDP**：由于不需要建立连接和确认机制，速度相对较快。



5. **头部开销**：

  - **TCP**：头部至少包含20字节，如果包含选项则更大，增加了开销。

  - **UDP**：头部固定为8字节，开销较小。



6. **错误处理**：

  - **TCP**：有错误检测和重传机制，能够处理数据传输过程中的错误。

  - **UDP**：没有错误检测和重传机制，错误处理由上层应用负责。



7. **用途**：

  - **TCP**：适用于需要可靠传输的应用，如Web浏览（HTTP）、文件传输（FTP）、邮件传输（SMTP）等。

  - **UDP**：适用于对实时性要求高的应用，如在线游戏、视频会议、DNS查询等。



8. **端口号**：

  - **TCP**和**UDP**：都使用端口号来标识特定的服务或应用程序，端口号范围从0到65535。



9. **资源消耗**：

  - **TCP**：由于需要维护连接状态，资源消耗相对较大。

  - **UDP**：不需要维护连接状态，资源消耗相对较小。



总的来说，TCP提供了一种可靠的、面向连接的通信方式，适合需要保证数据完整性的应用；而UDP提供了一种快速的、无连接的通信方式，适合对实时性要求高的应用。选择哪种协议取决于具体的应用需求。

# 进程通信有几种方式?

进程通信是操作系统中不同进程之间传递数据和信号的一种机制。以下是一些常见的进程通信方式：



1. **管道（Pipe）**：

  - 管道是一种最基本的进程间通信机制，允许两个进程进行单向通信。它通常用于父子进程或有亲缘关系的进程之间的通信。



2. **命名管道（Named Pipe 或 FIFO）**：

  - 命名管道允许不相关的进程以类似文件的方式进行通信，它允许多个进程从不同的终端或会话中读写同一个管道。



3. **信号（Signal）**：

  - 信号是一种软件中断，用于通知进程某个事件已经发生，如按键、非法内存访问等。



4. **消息队列（Message Queue）**：

  - 消息队列允许进程以消息的形式交换数据，消息被存储在队列中，直到被接收进程读取。



5. **信号量（Semaphore）**：

  - 信号量是一种计数器，用于控制多个进程对共享资源的访问，以实现同步和互斥。



6. **共享内存（Shared Memory）**：

  - 共享内存是一种最快的进程间通信方式，它允许两个或多个进程共享一个给定的存储区。



7. **套接字（Socket）**：

  - 套接字是一种网络通信的方式，但也可用于本机进程间通信。它支持面向连接（如TCP）和无连接（如UDP）的通信。



8. **内存映射文件（Memory-mapped File）**：

  - 内存映射文件将文件或设备映射到进程的地址空间，使得进程可以直接对文件进行操作，而不需要读写磁盘。



9. **事件（Event）**：

  - 事件是一种同步机制，用于通知一个或多个等待的进程某个条件已经满足。



10. **条件变量（Condition Variable）**：

  - 条件变量通常与互斥锁一起使用，用于在某些条件满足之前挂起进程，在条件满足后唤醒进程。



11. **屏障（Barrier）**：

  - 屏障是一种同步机制，用于让一组进程相互等待，直到所有进程都到达屏障点。



12. **读写锁（Read-Write Lock）**：

  - 读写锁允许多个进程同时读取数据，但写入数据时需要独占访问。



这些进程通信方式各有优缺点，适用于不同的场景。在实际应用中，开发者会根据具体需求选择合适的通信机制。

# 智能指针何时需要手动释放

在C++中，智能指针的设计初衷是自动管理动态分配的内存，以减少内存泄漏和其他资源管理错误。通常情况下，你不需要手动释放智能指针所管理的资源，因为智能指针会在其析构函数中自动释放资源。但是，有几种情况你可能需要手动释放智能指针：



1. **转移所有权**：

  如果你需要将智能指针所管理的资源的所有权转移给另一个智能指针，你可以使用`std::move`来转移所有权，而不是释放资源。例如：

  ```cpp

  std::unique_ptr<int> ptr1(new int(10));

  std::unique_ptr<int> ptr2 = std::move(ptr1); // ptr1不再拥有资源

  ```



2. **提前释放资源**：

  在某些情况下，你可能需要在智能指针的生命周期结束之前释放资源。例如，如果资源的释放需要执行一些额外的操作，或者你需要立即释放资源以避免资源泄露。你可以使用`reset`方法来释放资源：

  ```cpp

  std::unique_ptr<int> ptr(new int(10));

  ptr.reset(); // 释放资源，ptr不再拥有资源

  ```



3. **释放并获取原始指针**：

  有时候，你可能需要获取智能指针所管理的原始指针，以便进行一些特殊的操作，比如传递给一个只接受原始指针的函数。在这种情况下，你可以使用`release`方法来释放资源并获取原始指针：

  ```cpp

  std::unique_ptr<int> ptr(new int(10));

  int* raw_ptr = ptr.release(); // ptr不再拥有资源，需要手动释放raw_ptr

  delete raw_ptr; // 手动释放资源

  ```



4. **使用原始指针**：

  如果你需要将智能指针转换为原始指针，并且不希望智能指针再管理该资源，可以使用`release`方法。这通常用于将资源传递给其他需要拥有资源所有权的代码。



5. **与原始指针交互**：

  在某些情况下，你可能需要将智能指针转换为原始指针，以便与一些只接受原始指针的API或库进行交互。在这种情况下，你需要确保在适当的时候手动释放资源。



6. **异常安全和资源管理**：

  在涉及异常安全的复杂资源管理场景中，你可能需要在异常发生之前手动释放资源，以避免资源泄露。


# Inline能否修饰虚函数

在C++中，`inline` 关键字可以用来修饰虚函数，但这样做并不总是会产生预期的效果。`inline` 的主要目的是减少函数调用的开销，通过在编译时将函数体插入到每个调用点来实现。然而，对于虚函数来说，`inline` 的效果可能会受到限制。



### 虚函数和`inline`的组合



1. **编译器优化**：

  - 编译器在处理`inline`虚函数时，如果能够确定调用的确切函数版本（即在编译时可以确定哪个版本的虚函数将被调用），它可能会内联该函数。这通常发生在虚函数是通过指向具体类的指针或引用调用的，且该指针或引用在编译时已经指向了具体的类。



2. **运行时多态**：

  - 如果虚函数的调用依赖于运行时的多态性（即通过基类的指针或引用调用），编译器通常不会内联这样的虚函数。这是因为编译器在编译时无法确定将调用哪个具体的函数实现，因此无法安全地进行内联。



### 示例



下面是一个简单的示例，展示`inline`虚函数的使用：



```cpp

#include <iostream>



class Base {

public:

  virtual void print() const {

    std::cout << "Base::print()" << std::endl;

  }

};



class Derived : public Base {

public:

  inline virtual void print() const override {

    std::cout << "Derived::print()" << std::endl;

  }

};



int main() {

  Derived d;

  Base* b = &d;

  b->print(); // 这里可能会内联Derived::print，因为编译时已知b指向Derived

  d.print(); // 这里可能会内联Derived::print，因为d是Derived类型

}

```



在这个例子中，`Derived::print` 被声明为`inline`。如果`print`是通过`Derived`类型的引用或指针调用的，编译器可能会内联这个函数。然而，如果`print`是通过`Base`类型的指针调用的，且编译器无法确定这个指针实际上指向的是`Derived`对象，那么编译器可能不会内联这个函数。



### 结论



虽然`inline`可以用于修饰虚函数，但其效果取决于调用的具体情况。在编译时能够确定调用哪个函数版本的情况下，`inline`可能有效。然而，在运行时多态的情况下，`inline`虚函数的效果可能会受到限制。因此，依赖`inline`来优化虚函数可能不是最佳实践，特别是在依赖运行时多态的场景中。

# C语言与C++的区别?
C语言和C++都是广泛使用的编程语言，它们有很多相似之处，尤其是在基本语法和底层操作方面。然而，C++是在C的基础上发展起来的，增加了面向对象编程（OOP）的特性，以及其他一些高级特性。以下是C语言和C++的一些主要区别：



1. **面向对象编程（OOP）**：

  - **C++**：支持面向对象编程，包括类（class）、对象（object）、继承（inheritance）、多态（polymorphism）和封装（encapsulation）。

  - **C**：不支持面向对象编程，只支持过程化编程。



2. **类和对象**：

  - **C++**：可以使用类来创建自定义数据类型，并且可以创建对象实例。

  - **C**：没有类的概念，只能使用结构体（struct）来模拟类的部分功能，但不能模拟方法和继承。



3. **模板**：

  - **C++**：支持模板编程，允许编写泛型代码，可以用于创建泛型函数和泛型类。

  - **C**：没有模板，只能使用宏（macro）来实现简单的泛型编程。



4. **异常处理**：

  - **C++**：支持异常处理机制，可以使用`try`、`catch`和`throw`关键字来处理异常。

  - **C**：不支持异常处理，通常使用返回值和错误码来处理错误。



5. **标准模板库（STL）**：

  - **C++**：提供了标准模板库，包括容器（如向量、列表、映射等）、迭代器、算法等。

  - **C**：没有内置的容器和算法库，需要手动实现或使用第三方库。



6. **自动类型推导**：

  - **C++**：从C++11开始，支持自动类型推导，可以使用`auto`关键字让编译器自动推断变量类型。

  - **C**：不支持自动类型推导，必须显式声明变量类型。



7. **内存管理**：

  - **C++**：除了C风格的内存管理（如`malloc`和`free`），还提供了智能指针（如`std::unique_ptr`和`std::shared_ptr`）来自动管理内存。

  - **C**：只有C风格的内存管理，需要手动分配和释放内存。



8. **函数重载**：

  - **C++**：支持函数重载，即可以在同一个作用域内定义多个同名函数，只要它们的参数列表不同。

  - **C**：不支持函数重载，只能通过宏或函数指针等手段模拟重载。



9. **操作符重载**：

  - **C++**：支持操作符重载，可以为自定义类型定义操作符的行为。

  - **C**：不支持操作符重载，所有操作符都是内置的，不能为自定义类型重定义。



10. **命名空间**：

  - **C++**：支持命名空间（namespace），用于避免命名冲突。

  - **C**：不支持命名空间，通常使用前缀或包含-guard来避免命名冲突。



11. **多重继承**：

  - **C++**：支持多重继承，一个类可以继承多个基类。

  - **C**：不支持多重继承。



这些区别使得C++在某些方面比C更加强大和灵活，尤其是在大型项目和需要面向对象编程的场景中。然而，C语言因其简单性和接近硬件的特性，在系统编程、嵌入式编程等领域仍然非常流行。

# 构函数可以写成虚函数吗？为什么？

在C++中，析构函数可以写成虚函数，而且在某些情况下，这样做是必要的。当一个类是作为基类设计的，并且预期会有派生类时，将基类的析构函数声明为虚函数是一个好的编程实践。这样做的原因是确保在使用基类指针或引用来删除派生类对象时，能够正确地调用派生类的析构函数。



### 为什么需要虚析构函数



1. **确保正确的析构**：

  - 如果基类的析构函数不是虚的，那么当通过基类指针或引用来删除派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致资源泄漏，因为派生类的析构函数通常负责释放派生类中特有的资源。



2. **多态性**：

  - 虚析构函数允许基类指针或引用来多态地删除派生类对象。这意味着，当基类指针或引用指向派生类对象时，删除该指针或引用将自动调用正确的析构函数。



### 示例



以下是一个简单的示例，说明虚析构函数的使用：



```cpp

#include <iostream>



class Base {

public:

  virtual ~Base() {

    std::cout << "Base destructor called" << std::endl;

  }

};



class Derived : public Base {

public:

  ~Derived() {

    std::cout << "Derived destructor called" << std::endl;

  }

};



int main() {

  Base* b = new Derived();

  delete b; // 通过基类指针删除派生类对象

}

```



在这个例子中，`Base`类的析构函数被声明为虚函数。当通过基类指针`b`删除`Derived`类对象时，首先调用`Derived`类的析构函数，然后调用`Base`类的析构函数。如果`Base`类的析构函数不是虚的，那么只会调用`Base`类的析构函数，而不会调用`Derived`类的析构函数。



### 结论



将基类的析构函数声明为虚函数是一个重要的编程习惯，它确保了在使用基类指针或引用来删除派生类对象时，能够正确地调用派生类的析构函数，从而避免资源泄漏和确保对象的正确析构。

# 父类的析构函数为什么要加virtual
在C++中，多态主要涉及到基类和派生类的析构函数和构造函数的调用顺序，尤其是当对象通过基类的指针或引用创建和销毁时。以下是多态情况下构造函数和析构函数的调用顺序：



### 构造函数的调用顺序



1. **基类构造函数**：

  - 首先调用基类的构造函数。如果存在多个基类，则按照它们在类派生列表中的声明顺序进行调用。



2. **成员对象构造函数**：

  - 接着调用成员对象的构造函数。成员对象的构造顺序取决于它们在类定义中的声明顺序。



3. **派生类构造函数**：

  - 最后调用派生类的构造函数。



### 析构函数的调用顺序



1. **派生类析构函数**：

  - 首先调用派生类的析构函数。



2. **成员对象析构函数**：

  - 接着调用成员对象的析构函数。成员对象的析构顺序与它们的构造顺序相反，即最后构造的成员对象首先被析构。



3. **基类析构函数**：

  - 最后调用基类的析构函数。如果存在多个基类，则按照它们在类派生列表中声明的逆顺序进行调用。



### 示例



以下是构造函数和析构函数调用顺序的示例：



```cpp

#include <iostream>



class Base {

public:

  Base() { std::cout << "Base constructor called" << std::endl; }

  virtual ~Base() { std::cout << "Base destructor called" << std::endl; }

};



class Derived : public Base {

public:

  Derived() { std::cout << "Derived constructor called" << std::endl; }

  ~Derived() { std::cout << "Derived destructor called" << std::endl; }

};



int main() {

  {

    Derived d;

    std::cout << "End of main scope" << std::endl;

  } // d离开作用域，开始析构

  return 0;

}

```



在这个例子中，输出将显示以下顺序：



```

Base constructor called

Derived constructor called

End of main scope

Derived destructor called

Base destructor called

```



这个顺序展示了构造函数从基类到派生类的顺序，以及析构函数从派生类到基类的顺序。



### 结论



在多态的情况下，构造函数的调用顺序是从基类到派生类，而析构函数的调用顺序是从派生类到基类。这种顺序确保了对象的正确构造和析构，以及资源的正确管理。

# 请实现一个单向链表，并包括插入、删除和遍历功能。

```cpp
#include <stdio.h>

#include <stdlib.h>



// 实现一个单向链表，并包括插入、删除和遍历功能。



typedef struct Node

{

  int val;

  struct Node *next;

} Node;



Node *createNode(int val)

{

  Node *node = (Node *)malloc(sizeof(Node));

  node->val = val;

  node->next = NULL;

  return node;

}



// 头插法

void insertNode(Node *header, int val)

{

  if (header == NULL)

  {

    perror("header is NULL");

    return;

  }

  if (header->next == NULL)

  {

    header->next = createNode(val);

    return;

  }

  Node *node = createNode(val);

  node->next = header->next;

  header->next = node;

}



// 尾插法

void insertNodeToTail(Node *header, int val)

{

  if (header == NULL)

  {

    perror("header is NULL");

    return;

  }

  if (header->next == NULL)

  {

    header->next = createNode(val);

    return;

  }

  // 运用遍历查找最后的一个节点

  Node *node = header->next;

  while(node->next!=NULL){

    node=node->next;

  }

  node->next = createNode(val);

  



}



// 删除节点

/**

 * 删除链表中指定值的节点。

 *

 * @param header 链表的头节点指针。

 * @param val 要删除的节点的值。

 */

void deleteNode(Node *header, int val)

{

  // 检查头节点是否为空

  if (header == NULL)

  {

    // 如果头节点为空，输出错误信息并返回

    perror("header is NULL");

    return;

  }

  // 检查头节点的下一个节点是否为空

  if (header->next == NULL)

  {

    // 如果头节点的下一个节点为空，输出错误信息并返回

    perror("header->next is NULL");

    return;

  }

  // 初始化当前节点为头节点的下一个节点

  Node *node = header->next;

  // 初始化前一个节点为头节点

  Node *pre = header;

  // 遍历链表，直到当前节点为空

  while (node != NULL)

  {

    // 如果当前节点的值等于要删除的值

    if (node->val == val)

    {

      // 将前一个节点的下一个指针指向当前节点的下一个节点

      pre->next = node->next;

      // 释放当前节点的内存

      free(node);

      // 删除成功，返回

      return;

    }

    else

    {

      // 如果当前节点的值不等于要删除的值，将前一个节点更新为当前节点

      pre = node;

      // 将当前节点更新为下一个节点

      node = node->next;

    }

  }

  // 如果遍历完链表都没有找到要删除的值，输出错误信息并返回

  perror("not found val");

}



// 遍历节点

void traverseNode(Node *header){

  if (header == NULL){

    perror("header is NULL");

    return;



  }

  if (header->next == NULL){

    perror("header->next is NULL");

    return;

  }

  Node *node=header->next;

  while (node!=NULL){

    printf("%d ",node->val);

    node=node->next;

  }

}



int main()

{

  Node *header = (Node *)malloc(sizeof(Node));

  header->next = NULL;

  header->val = -1;



  //随机生成节点测试功能

  for (int i = 0; i < 10; i++){

    insertNode(header,rand()%100);

  }

  traverseNode(header);

  printf("\n");

  insertNode(header,20);

  traverseNode(header);

  printf("\n");



  deleteNode(header,20);

  traverseNode(header);

  printf("\n");

  //尾插法测试功能

  insertNodeToTail(header,100);

  traverseNode(header);

  printf("\n");



  deleteNode(header,83);

  traverseNode(header);

  printf("\n");

free(header);

  return 0;

}

```

# 实现一个栈，要求支持push、pop和检查栈是否为空的功能
```cpp

#include <stdio.h>

#include <stdlib.h>

// 实现一个栈，要求支持push、pop和检查栈是否为空的功能。

typedef struct Stack

{

    int val;

    struct Stack *next;

} Stack;

Stack *createNode(int val)

{

    Stack *node = (Stack *)malloc(sizeof(Stack));

    node->val = val;

    node->next = NULL;

    return node;

}



// check empty stack

int isEmpty(Stack *stack)

{

    if (stack == NULL)

    {

        return 1;

    }

    return 0;

}

// push

void push(Stack *stack, int val)

{

    if (isEmpty(stack) == 1)

    {

        perror("stack is NULL");

        return;

    }

    if (stack->next == NULL)

    {

        stack->next = createNode(val);

        return;

    }



    while (stack->next != NULL)

    {

        stack = stack->next;

    }

    Stack *node = createNode(val);

    stack->next = node;

}

// pop

int pop(Stack *stack)

{

    

    if (isEmpty(stack) == 1)

    {

        perror("stack is NULL");

        return -1;

    }

    if (stack->next == NULL)

    {

        perror("stack is empty");

        return -1;

    }

    

    while (1)

    {

        if (stack->next->next!= NULL){



        stack = stack->next;

        }else{

            break;

        }

        

    }

    Stack *temp = stack->next;

    stack->next = NULL;

    free(temp);

    return 1;

}



void destoryStack(Stack *stack)

{

    if (isEmpty(stack) == 1)

    {

        perror("stack is NULL");

        return;

    }

    while (stack->next != NULL)

    {

        Stack *temp = stack->next;

        free(stack);

        stack = temp;

        

    }

}



int main()

{

    Stack *header= (Stack *)malloc(sizeof(Stack));

    header->next = NULL;

    Stack *stack = header;

    // 只通过栈的pop和push进行新建和删除节点操作

    for (int i = 0; i < 9; i++)

    {

        push(stack, rand() % 30);

    }

    Stack *pointer = stack;

    for (int i = 0; pointer->next != NULL; i++)

    {

        

        pointer = pointer->next;

        printf("value[%d]=%d\n", i, pointer->val);

    }



    printf("Pop is %s.\n",pop(stack)?"Success":"Fail");



    pointer = stack;

    for (int i = 0; pointer->next != NULL; i++)

    {

        

        pointer = pointer->next;

        printf("value[%d]=%d\n", i, pointer->val);

    }

    destoryStack(stack);

    return 0;

}

```

# 数组与链表的区别是什么？在哪些场景下你会选择使用数组，哪些场景下会选择使用链表？
数组与链表的区别

1. 存储方式

数组：数组是一种线性数据结构，其中所有元素在内存中是连续存储的。每个元素可以通过索引直接访问。

链表：链表也是一种线性数据结构，但它的元素在内存中不是连续存储的。每个元素（节点）包含数据部分和一个指向下一个节点的指针。

2. 访问方式

数组：由于数组元素在内存中是连续的，因此可以通过索引直接访问任意元素，时间复杂度为 O(1)。

链表：链表需要从头节点开始逐个遍历，直到找到目标节点，时间复杂度为 O(n)。

3. 插入和删除操作

数组：

插入：在数组中间插入元素时，需要将插入点之后的所有元素向后移动一位，时间复杂度为 O(n)。

删除：在数组中间删除元素时，需要将删除点之后的所有元素向前移动一位，时间复杂度为 O(n)。

链表：

插入：在链表中插入元素时，只需要修改指针，时间复杂度为 O(1)（假设已经找到了插入位置）。

删除：在链表中删除元素时，同样只需要修改指针，时间复杂度为 O(1)（假设已经找到了删除位置）。

4. 内存分配

数组：数组在创建时需要预先分配固定大小的内存空间，如果数组大小不足，需要重新分配更大的内存并复制原有数据。

链表：链表可以根据需要动态分配内存，不需要预先确定大小。

场景选择

使用数组的场景

频繁访问元素：如果你需要频繁地通过索引访问元素，数组是一个很好的选择，因为它的访问时间复杂度为 O(1)。

固定大小的数据集：如果你的数据集大小是固定的或变化不大，使用数组可以更高效地管理内存。

多维数据：数组可以方便地表示多维数据结构，如二维数组、三维数组等。

使用链表的场景

频繁插入和删除：如果你需要频繁地在列表中间插入或删除元素，链表是一个更好的选择，因为它的插入和删除操作时间复杂度为 O(1)。

动态数据集：如果你的数据集大小经常变化，链表可以动态地分配和释放内存，更加灵活。

节省内存：对于非常大的数据集，链表可以节省内存，因为它不需要预先分配连续的大块内存。

总结

数组适合于需要快速访问元素且数据集大小固定或变化不大的场景。

链表适合于需要频繁插入和删除元素且数据集大小经常变化的场景。

# 实现一个哈希表，要求支持插入、查找和删除操作。

```cpp

#include <stdio.h>

#include <stdlib.h>

#include <string.h> 



typedef struct HashNode {

    char key[100];

    int value;

} HashNode;



int find(HashNode hashTable[], const char key[], int size) {

    for (int i = 0; i < size; i++) {

        if (strcmp(hashTable[i].key, key) == 0) {

            return i;

        }

    }

    return -1;

}



int insert(HashNode hashTable[], const char key[], int value, int *size, int capacity) {

    if (*size >= capacity || find(hashTable, key, *size) != -1) {

        return -1;

    }

    strcpy(hashTable[*size].key, key);

    hashTable[*size].value = value;

    (*size)++;

    return 1;

}



int delete(HashNode hashTable[], const char key[], int *size) {

    int index = find(hashTable, key, *size);

    if (index == -1) {

        return -1;

    }

    for (int i = index; i < *size - 1; i++) {

        strcpy(hashTable[i].key, hashTable[i + 1].key);

        hashTable[i].value = hashTable[i + 1].value;

    }

    // Clear the last element

    memset(hashTable[*size - 1].key, 0, sizeof(hashTable[*size - 1].key));

    hashTable[*size - 1].value = 0;

    (*size)--;

    return 1;

}



int main() {

    HashNode hashTable[100];

    int size = 0;



    insert(hashTable, "c", 1, &size, 100);

    insert(hashTable, "b", 2, &size, 100);

    insert(hashTable, "c", 3, &size, 100);



    int indexA = find(hashTable, "a", size);

    if (indexA != -1) {

        printf("%d, key:%s, value:%d\n", indexA, hashTable[indexA].key, hashTable[indexA].value);

    } else {

        printf("Key 'a' not found\n");

    }



    int indexB = find(hashTable, "b", size);

    if (indexB != -1) {

        printf("%d, key:%s, value:%d\n", indexB, hashTable[indexB].key, hashTable[indexB].value);

    }



    printf("%d\n", find(hashTable, "c", size));



    delete(hashTable, "d", &size);

    printf("%d\n", find(hashTable, "a", size));



    return 0;

}
```

# 实现一个二叉搜索树（BST），并包括插入、查找和删除节点的功能。
```cpp 
#include <stdio.h>

#include <stdlib.h>

#include <string.h>



typedef struct TreeNode {

  int val;

  struct TreeNode* left;

  struct TreeNode* right;

} TreeNode;



TreeNode* createNode(int val) {

  TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));

  newNode->val = val;

  newNode->left = NULL;

  newNode->right = NULL;

  return newNode;

}



TreeNode* insert(TreeNode* root, int val) {

  if (root == NULL) {

    return createNode(val);

  }

  if (val < root->val) {

    root->left = insert(root->left, val);

  } else if (val > root->val) {

    root->right = insert(root->right, val);

  }

  return root;

}



TreeNode* search(TreeNode* root, int val) {

  if (root == NULL || root->val == val) {

    return root;

  }

  if (val < root->val) {

    return search(root->left, val);

  } else {

    return search(root->right, val);

  }

}



TreeNode* findMin(TreeNode* node) {

  while (node->left != NULL) {

    node = node->left;

  }

  return node;

}



TreeNode* deleteNode(TreeNode* root, int val) {

  if (root == NULL) {

    return root;

  }

  if (val < root->val) {

    root->left = deleteNode(root->left, val);

  } else if (val > root->val) {

    root->right = deleteNode(root->right, val);

  } else {

    if (root->left == NULL) {

      TreeNode* temp = root->right;

      free(root);

      return temp;

    } else if (root->right == NULL) {

      TreeNode* temp = root->left;

      free(root);

      return temp;

    }

    // Node with two children: Get the inorder successor (smallest in the right subtree)

    TreeNode* temp = findMin(root->right);

    root->val = temp->val;

    root->right = deleteNode(root->right, temp->val);

  }

  return root;

}



void printInOrder(TreeNode* root) {

  if (root != NULL) {

    printInOrder(root->left);

    printf("%d ", root->val);

    printInOrder(root->right);

  }

}



int main() {

  TreeNode* root = NULL;

  root = insert(root, 50);

  root = insert(root, 30);

  root = insert(root, 20);

  root = insert(root, 40);

  root = insert(root, 70);

  root = insert(root, 60);

  root = insert(root, 80);



  printf("In-order traversal of the constructed BST:\n");

  printInOrder(root);

  printf("\n");



  int searchVal = 40;

  TreeNode* found = search(root, searchVal);

  if (found != NULL) {

    printf("Value %d found in the BST.\n", searchVal);

  } else {

    printf("Value %d not found in the BST.\n", searchVal);

  }



  int deleteVal = 20;

  root = deleteNode(root, deleteVal);

  printf("BST after deleting %d:\n", deleteVal);

  printInOrder(root);

  printf("\n");



  int deleteVal2 = 50;

  root = deleteNode(root, deleteVal2);

  printf("BST after deleting %d:\n", deleteVal2);

  printInOrder(root);

  printf("\n");



  return 0;

}
```

# 请描述一下堆（Heap）的概念，并给出最大堆和最小堆的插入和删除操作的实现思路。

堆（Heap）是一种特殊的完全二叉树，它满足堆性质：对于任意节点i（0索引），其值都满足以下条件：



1. **最大堆**：父节点的值总是大于或等于其子节点的值。即对于任意节点i，`A[i] >= A[2*i+1]` 且 `A[i] >= A[2*i+2]`。

2. **最小堆**：父节点的值总是小于或等于其子节点的值。即对于任意节点i，`A[i] <= A[2*i+1]` 且 `A[i] <= A[2*i+2]`。



这里的`A`表示堆数组，`A[i]`表示堆中的第i个元素，其中`i`为索引。在数组中，父节点和子节点的索引关系如下：



- 父节点索引为`i`的左子节点索引为`2*i+1`。

- 父节点索引为`i`的右子节点索引为`2*i+2`。

- 索引为`i`的节点的父节点索引为`(i-1)/2`（向下取整）。



### 最大堆的插入操作



1. **插入元素**：将新元素添加到堆的末尾（数组的最后一个位置）。

2. **上浮调整**：从新元素的位置开始，将其与其父节点比较，如果新元素比父节点大，则交换它们的位置；继续这个过程，直到新元素不再比父节点大或者新元素成为根节点。



### 最大堆的删除操作（删除根节点）



1. **替换根节点**：将堆的最后一个元素（末尾元素）复制到根节点的位置。

2. **缩小堆**：删除堆的最后一个元素（因为已经复制到了根节点的位置）。

3. **下沉调整**：从根节点开始，将其与子节点比较，如果根节点比子节点小，则与最大的子节点交换位置；继续这个过程，直到根节点不再比子节点小或者根节点没有子节点。



### 最小堆的插入操作



1. **插入元素**：将新元素添加到堆的末尾（数组的最后一个位置）。

2. **上浮调整**：从新元素的位置开始，将其与其父节点比较，如果新元素比父节点小，则交换它们的位置；继续这个过程，直到新元素不再比父节点小或者新元素成为根节点。



### 最小堆的删除操作（删除根节点）



1. **替换根节点**：将堆的最后一个元素（末尾元素）复制到根节点的位置。

2. **缩小堆**：删除堆的最后一个元素（因为已经复制到了根节点的位置）。

3. **下沉调整**：从根节点开始，将其与子节点比较，如果根节点比子节点大，则与最小的子节点交换位置；继续这个过程，直到根节点不再比子节点大或者根节点没有子节点。



在实际实现中，通常会使用数组来表示堆，因为数组可以方便地通过索引计算出父节点和子节点的位置。堆的插入和删除操作的时间复杂度都是O(log n)，其中n是堆中元素的数量。

# 给定一个无序数组，请编写一个函数来找到数组中的第k个最大元素。

```cpp
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <pthread.h>

#include <unistd.h>

#include <time.h>

#define NUM_THREADS 4

#define ARRAY_SIZE 100

// 给一个无序数组，用四个线程来同时找最大值，四个线程中保存最大值的变量为共享变量，使用互斥锁来保护共享变量



// 定义一个互斥锁

pthread_mutex_t mutex;

int max_share = -1;



void *findMax(void *arg)

{

    int *array = (int *)arg;

    int max = -1;

    for (int i = 0; i < ARRAY_SIZE / NUM_THREADS; i++)

    {

        if (array[i] > max)

        {

            max = array[i];

            // printf("max = %d, for thread:%ld\n", max, pthread_self());

        }

    }

    printf("max = %d, for thread:%ld\n", max, pthread_self());

    // 加锁

    pthread_mutex_lock(&mutex);

    if (max > max_share)

    {

        max_share = max;

    }

    // 解锁

    pthread_mutex_unlock(&mutex);

}



int main()

{

    // 初始化互斥锁

    pthread_mutex_init(&mutex, NULL);



    int array[100];

    srand((unsigned int)time(NULL));//只需要调用一次srand()，rand()函数会自动给出随机数

    for (int i = 0; i < 100; i++)

    {



        // 利用时间种子来生成随机数

        array[i] = rand() % 100;

        // printf("%d ", array[i]);

        // if (i % 10 == 0)

        // {

        //     printf("\n");

        // }

    }



    // 定义四个线程

    pthread_t thread[NUM_THREADS];



    // 启动四个线程

    for (int i = 0; i < NUM_THREADS; i++)

    {

        pthread_create(&thread[i], NULL, findMax, (void *)(array + i * ARRAY_SIZE / NUM_THREADS));

    }

    // 等待四个线程结束

    for (int i = 0; i < NUM_THREADS; i++)

    {

        pthread_join(thread[i], NULL);

    }



    printf("max = %d\n", max_share);



    // 销毁互斥锁

    pthread_mutex_destroy(&mutex);



    return 0;

}
```
@HousirChen

# 如何理解Python装饰器的？

Python装饰器（Decorator）是一种设计模式，它允许用户在不修改原有函数代码的情况下，给函数添加新的功能。装饰器本质上是一个Python函数，它接受一个函数作为参数并返回一个新的函数。装饰器的使用提高了代码的可复用性和可读性，是Python中非常强大的功能之一。



### 装饰器的基本概念



- **函数作为一等公民**：在Python中，函数是一等公民，这意味着函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。

- **嵌套函数**：Python允许在函数内部定义函数，这些内部函数可以访问外部函数的局部变量。

- **闭包**：一个函数返回另一个函数时，内部函数可以访问外部函数的局部变量，即使外部函数已经执行完毕，这种特性称为闭包。



### 装饰器的工作原理



1. **定义装饰器**：

  - 装饰器是一个函数，它接受一个函数作为参数。

  - 在装饰器内部，定义一个嵌套函数，这个嵌套函数通常会调用传入的函数，并在调用前后添加一些额外的逻辑。

  - 装饰器返回这个嵌套函数。



2. **使用装饰器**：

  - 在函数定义前使用`@decorator_name`语法来应用装饰器。

  - 当调用被装饰的函数时，实际上是调用了装饰器返回的嵌套函数。



### 装饰器的示例



下面是一个简单的装饰器示例，用于计算函数的执行时间：



```python

import time



def timer(func):

  def wrapper(*args, **kwargs):

    start_time = time.time()

    result = func(*args, **kwargs)

    end_time = time.time()

    print(f"{func.__name__} took {end_time - start_time} seconds to execute.")

    return result

  return wrapper



@timer

def example_function():

  time.sleep(2)

  print("Function is running...")



example_function()

```



### 装饰器的应用场景



- **日志记录**：在函数执行前后记录日志信息。

- **性能监控**：计算函数的执行时间，用于性能分析。

- **权限检查**：在函数执行前检查用户权限。

- **缓存结果**：缓存函数的返回结果，避免重复计算。

- **事务管理**：在数据库操作前后管理事务的开启和提交。



### 装饰器的高级用法



- **带参数的装饰器**：装饰器本身也可以接受参数，这需要在装饰器外层再嵌套一层函数。

- **类装饰器**：使用类来实现装饰器，类的`__call__`方法使得类的实例可以像函数一样被调用。

- **多层装饰器**：可以将多个装饰器应用于同一个函数，装饰器的执行顺序是从近到远。



装饰器是Python中一个非常灵活和强大的工具，它使得代码更加模块化和可维护。通过合理使用装饰器，可以有效地扩展函数的功能，而不需要修改函数本身的代码。